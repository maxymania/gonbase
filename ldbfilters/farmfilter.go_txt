// +build ignore

// Copyright (c) 2018 Simon Schmidt
// Copyright (c) 2012, Suryandaru Triandana <syndtr@gmail.com>
// All rights reserved.
//
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// ( https://github.com/syndtr/goleveldb/blob/master/LICENSE )

package ldbfilters

import farm "github.com/dgryski/go-farm"
import "github.com/syndtr/goleveldb/leveldb/filter"


type farmBloom int


// The bloom filter serializes its parameters and is backward compatible
// with respect to them. Therefor, its parameters are not added to its
// name.
func (farmBloom) Name() string {
	return "gonbase.FarmBloom"
}


func (f farmBloom) Contains(filter, key []byte) bool {
	nBytes := len(filter) - 1
	if nBytes < 1 {
		return false
	}
	nBits := uint64(nBytes * 8)
	
	// Use the encoded k so that we can read filters generated by
	// bloom filters created using different parameters.
	k := filter[nBytes]
	
	kh := farm.Fingerprint64(key)
	delta := (kh >> 33) | (kh << 31) // Rotate right 17 bits
	for j := uint8(0); j < k; j++ {
		bitpos := kh % nBits
		if (uint32(filter[bitpos/8]) & (1 << (bitpos % 8))) == 0 {
			return false
		}
		kh += delta
	}
	return true
}
func (f farmBloom) NewGenerator() filter.FilterGenerator {
	// Round down to reduce probing cost a little bit.
	k := uint8(f * 69 / 100) // 0.69 =~ ln(2)
	if k < 1 {
		k = 1
	} else if k > 30 {
		k = 30
	}
	return &farmBloomGenerator{
		n: int(f),
		k: k,
	}
}

type farmBloomGenerator struct {
	n int
	k uint8

	keyHashes []uint64
}
func (g *farmBloomGenerator) Add(key []byte) {
	g.keyHashes = append(g.keyHashes, farm.Fingerprint64(key))
}

func (g *farmBloomGenerator) Generate(b filter.Buffer) {
	// Compute bloom filter size (in both bits and bytes)
	nBits := uint64(len(g.keyHashes) * g.n)
	// For small n, we can see a very high false positive rate.  Fix it
	// by enforcing a minimum bloom filter length.
	if nBits < 64 {
		nBits = 64
	}
	nBytes := (nBits + 7) / 8
	nBits = nBytes * 8
	
	dest := b.Alloc(int(nBytes) + 1)
	dest[nBytes] = g.k
	for _, kh := range g.keyHashes {
		delta := (kh >> 33) | (kh << 31) // Rotate right 17 bits
		for j := uint8(0); j < g.k; j++ {
			bitpos := kh % nBits
			dest[bitpos/8] |= (1 << (bitpos % 8))
			kh += delta
		}
	}
	
	g.keyHashes = g.keyHashes[:0]
}

/*
Creates a bloom-filter that uses the 64-bit farmhash as hash function.
*/
func NewFarmBloom(bitsPerKey int) filter.Filter {
	return farmBloom(bitsPerKey)
}

